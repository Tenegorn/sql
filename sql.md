# Основные понятия.

`База данных (БД)` — это организованная структура, предназначенная для хранения, изменения и обработки взаимосвязанной информации, преимущественно больших объемов.

Существует огромное количество разновидностей баз данных, отличающихся по различным критериям. Одним из главных является классификация по модели данных (по методу хранения и обработки данных).

Классификация по модели данных:
- Иерархическая
- Объектная и объектно-ориентированная
- Объектно-реляционная
- Реляционная (MySQL, MS SQL, PostgreSQL)
- Сетевая
- Функциональная.

`Система управления базами данных (СУБД)` — это комплекс программных средств, необходимых для создания структуры новой базы, ее наполнения, редактирования содержимого и отображения информации. Наиболее распространенными СУБД являются MySQL, PostgreSQL, Oracle, Microsoft SQL Server.

`SQL` - язык структурированных запросов, основной задачей которого является предоставление простого способа считывания и записи информации в базу данных.

Простейшая схема работы:
`SQL запрос -> СУБД -> БД -> СУБД -> Данные.`

# Реляционные базы данных. MySQL.

Реляционные базы данных состоят из таблиц (сущностей). Каждая таблица состоит из столбцов (поля или атрибуты) и строк (записи или кортежи).

`MySQL` - свободная реляционная система управления базами данных.

Почти каждые СУБД имеют различные интерфейсы для удобного администрирования СУБД. 
Одним из самых популярных является `phpMyAdmin` - веб-приложение с открытым кодом, написанное на языке PHP и представляющее собой веб-интерфейс для администрирования СУБД MySQL.

Прежде, чем приступить к изучению SQL, необходимо понять, как же все таки хранятся данные в базе и как они связаны мужду собой.

Все начинается с проектирования БД. Построения `ER-модели` (entity-relationship model, модель «сущность-связь»). 

ER-модель используется при высокоуровневом (концептуальном) проектировании баз данных. С её помощью можно выделить ключевые сущности (таблицы) и обозначить связи, которые могут устанавливаться между этими сущностями (таблицами).

В качестве примера разберем укороченную модель работы магазина. И так у нас есть следующие сущности:

- Покупатели
- Товары
- Категории
- Заказы
- Дополнительная информация о заказе
- ...

Конечно есть еще много других сущностей: доставка, поставщики, сотрудники, отзывы и т.п. Но этих будет достаточно, чтобы спроектировать модель.

Теперь определяем основные поля каждой сущности и определяем связи. 

В итоге получаем такую модель, смотреть вложение `1.jpg`.

Например сущность категория (`categories`) содержит: уникальный идентификатор (`categoryID`), название категории (`categoryName`) и описание (`description`). Эта сущность имеет связь с сущностью товары (`products`), и связь которая между ними называется "один - к многим". Потому что  категория одна, а товаров которые могут быть в этой категории много.

Остальные сущности по аналогии.
После построения ER-модели приступаем к созданию БД.

# SQL. Создание базы данных `store`.

Использовать будем phpMyAdmin. 
https://demo.phpmyadmin.net/master-config/

#### Создание БД.

В phpMyAdmin переходим на таб  `<SQL>`.

Для того, чтобы создать базу данных, используется выражение `CREATE DATABASE <имя базы данных>.`

```SQL 
CREATE DATABASE `store`; 
```

С помощью кнопки `<GO>` справа или сочетания клавиш `ctrl+enter`, создаем БД `store`. Эта база отобразится с списке слева. Выбираем и снова переходим на таб <SQL>.


### Создание таблиц.

Для того, что создание таблицу используется выражение `CREATE TABLE <имя таблицы> (<столбцы>)`

```SQL
CREATE TABLE `customers` (
  `customerID` int(11),
  `customerName` varchar(45),
  `contactName` varchar(45),
  `address` varchar(45),
  `city` varchar(45),
  `postalCode` varchar(45),
  `country` varchar(45),
);
```
customerID - уникальный идентификатор, имеет целочисленный тип int (integer).

----
Полям в таблице всегда задается тип хранимых данных. Наиболее распространнеными являются: 
- `int` - целочисленный тип,
- `varchar` - строка (текст),
- `date` - дата,
- `bool` - булевое выражение, истина или ложь,
- `decimal` - числа с фиксированной точностью. В основном используется для валют.

Более подробную информацию по типам данных можно посмотреть здесь: https://metanit.com/sql/mysql/2.3.php.

### Заполнение таблиц данными.

Для того чтобы заполнить данные в таблицу используется выражение `INSERT INTO <имя таблица> (<данные>)`.

```sql
INSERT INTO `customers` VALUES 
(1,'Alfreds Futterkiste', 'Maria Anders', 'Obere Str. 57', 'Berlin', '12209', 'Germany');
```
И так мы научились создавать базу данных, создавать таблицы и заполнять данные. Проделываем ту же работу и для остальных таблиц. Смотреть файл `1.sql`.

Отлично выполнив полностью код, мы получим нашу базу данных с заполненными таблицами. Но наши данные не имеют связей (лишь мысленно), в этом мы можем убедиться посмотрев на схему модели. phpMyAdmin имеет хороший функционал построения ER-модели, для этого переходим в нашу базу данных.
Сверху в табах `<MORE>` -> `<DESIGNER>`, после нажатия, выведутся сущности без связей. Для того чтобы их связать можно дописать наш SQL код, либо же связать данные используя интерфейс phpMyAdmin.

### Первичные и внешние ключи. Связывание. 

Под `первичным ключом` понимают поле или набор полей, уникально идентифицирующих запись. 

Для обеспечения ссылочной целостности в дочерней таблице создается `внешний ключ`. Во внешний ключ входят поля связи дочерней таблицы. Для связей внешний ключ по составу полей должен совпадать с первичным ключом родительской таблицы.

Разберем на примере таблицы `customers` и `orders`. Они связаны мужду собой отношением "один ко многим", у каждого покупателя может быть много заказов. В таблице `customers` уникальным идентификатором будет являться `customerID`, он же и будет являться первичным ключом. Прописываем выражением: `PRIMARY KEY (<идентификатор>)`, а так же сделаем чтобы он не мог быть пустым и автоматически увеличивался `NOT NULL AUTO_INCREMENT`:

```sql
CREATE TABLE `customers` (
  `customerID` int(11) NOT NULL AUTO_INCREMENT,
  `customerName` varchar(45),
  `contactName` varchar(45),
  `address` varchar(45),
  `city` varchar(45),
  `postalCode` varchar(45),
  `country` varchar(45),
  PRIMARY KEY (`customerID`)
)
```

Далее рассмотрим таблицу `orders` в ней первичный ключ `orderID`. А вот внешним ключом ссылающимся на таблицу `customres` будет являться `customerID`, его прописываем внешним ключом. Используем выражение: `FOREIGN KEY (<имя стобца текущей таблицы>) REFERENCES <имя главной таблицы> (<первичный ключ главной таблицы>)`:

```sql
CREATE TABLE `orders` (
  `orderID` int(11),
  `customerID` int(11),
  `employeeID` int(11),
  `orderDate` DATE,
  `shipperID` int(11),
  PRIMARY KEY (`orderID`),
  FOREIGN KEY (`customerID`) REFERENCES `customers` (`customerID`)
);
```

Так же отмечу, что при такой связи, важен порядок создания таблиц, а так же при добавлении данных будет ошибка, если не будут найдены связи в данных. Например внешний ключ будет ссылаться на несуществующий первичный. Переделываем весь код, смотреть файл `2.sql` и исполняем в phpMyAdmin.

### Запросы в БД.

Рассмотрим как можно работать с данныеми в БД.

##### SELECT

Для того, чтобы показать данные в таблице используется слово: `SELECT`.

```sql
SELECT * FROM `customers`.
```

Результатом данного запроса будет таблица со всеми данными в таблице `customers`. Знак звёздочки (`*`) означает то, что мы хотим показать все столбцы из таблицы без исключений. Так как в базе данных обычно больше одной таблицы, нам необходимо указывать название таблицы, данные из которой мы хотим посмотреть., испоьзуем `FROM`.
Когда нужны дишь некоторые столбцы, то имена указываются через запятую:

```sql
SELECT `customerID`, `city` FROM `customers`
```

Выведутся два столбца. Иногда нужно отсортировать данные по какому то полю. Для этого используем `ORDER BY <название столбца> ASC (DESC)`. ASC (по возрастанию) (по умолчанию) и DESC (по убыванию).
Сортировать можно как строки (по алфавиту), так и числа.

```sql
SELECT `customerID`, `city` FROM `customers` ORDER BY `city` ASC
```
##### WHERE

Теперь мы знаем, как показать только конкретные столбцы, но что если мы хотим включить в вывод лишь некоторые конкретные строки? Для этого мы используем WHERE. Данное ключевое слово позволяет нам фильтровать данные по определённому условию.
В следующем запросе выведем покупателей из Лондона.

```sql
SELECT * 
FROM `customers`
WHERE `city` = 'London';
```

Но что если нам нужно вывести всех покупателей из Лондона и Мадрида, для этого условия в `WHERE` могут быть написаны с использованием логических операторов (`AND/OR`) и математические операторы сравнения (`=, <, >, <=, >=, <>`).

```sql
SELECT * 
FROM `customers`
WHERE `city` = 'London' OR `city` = 'Madrid'; 
```

Либо если хотим вывести все продукты выше цены 20.00:

```sql
SELECT * 
FROM `products`
WHERE `price` >= 20.00; 
```

##### In/Between/Like

Условия в `WHERE` могут быть записаны с использованием ещё нескольких команд, которыми являются:

- `IN` - сравнивает значение в столбце с несколькими возможными значениями и возвращает true, если значение совпадает хотя бы с одним значением
- `BETWEEN` - проверяет, находится ли значение в каком-то промежутке
- `LIKE` - ищет по шаблону

Что если нам нужно вытащить, 3 и более городов, то использовать схему выше будет не удобно, поэтому преобразуем код с помощью ключевого слова `IN`:

```sql    
SELECT * 
FROM `customers`
WHERE `city` IN ('London', 'Madrid', 'Berlin');
```

Выведем заказы которые были сделаны в с 1996-01-01 по 1997-01-01:

```sql
SELECT * FROM `orders`
WHERE `orderDate` BETWEEN '1996-01-01' AND '1997-01-01'; 
```

Выведем все продукты начинающиеся на С англ.

```sql
SELECT * FROM `products` WHERE `productName` LIKE 'C%';
```

Знак (`%`) означает любую последовательность символов (0 символов тоже считается за последовательность).

В SQL также есть инверсия. Попробуй самостоятельно написать `NOT` перед любым логическим выражением в условии (`NOT BETWEEN` и так далее).

---

#### Функции

В SQL полно встроенных функций для выполнения разных операций. Наиболее часто используемые:

- `COUNT()` - возвращает число строк
- `SUM()` - возвращает сумму всех полей с числовыми значениями в них
- `AVG()` - возвращает среднее значение среди строк
- `MIN()/MAX()` - возвращает минимальное/максимальное значение среди строк

Чтобы вывести самый дорогой заказ, в таблице `products` можно использовать следующий запрос:

```sql
SELECT MAX(`price`) FROM `products`
```
Средняя цена:

```sql
SELECT 'productName', avg(`price`) AS `price` FROM `products`;
```
Через ключ `AS` создается псевдоним для выводимого поля.

#### Вложенные Select

В предыдущих шагах мы изучили, как делать простые вычисления с данными. Теперь нам, допустим, необходимо вывести название продукта, категорию и самую низкую стоимость в таблице.

Вывести эти столбцы можно, используя следующий запрос:

```sql
SELECT `productName`, `categoryID`, `price` FROM `products`;
```
Также мы знаем, как получить самую низкую стоимость из имеющихся:

```sql
SELECT MIN(`price`) FROM `products`
```

Объединить эти запросы можно в `WHERE`:

```sql
SELECT `productName`, `categoryID`, `price` 
FROM `products`
WHERE `price` = ( 
SELECT MIN(`price`) FROM `products`
);
```
#### Присоединение таблиц

В предыдущем примере мы вывели товар с наименьшей ценой с полями, но поле `categoryID` не понятно, нет названия. Выясним какое название категории. Мы знаем, что таблицы `categories` и `products` связаны между собой первичным и внешним ключом. Для начала воспользуемся ключом `INNER JOIN`.

```sql
SELECT * FROM `products`
INNER JOIN `categories`
ON `categories`.`categoryID` = `products`.`categoryID`
```
Выведится вся информация о товарах и категориях.
Далее попробуем вывести только нужные нам параметры:

 ```sql
SELECT `products`.`productName`, `categories`.`categoryName`, `products`.`price` FROM `products`
INNER JOIN `categories` 
ON `categories`.`categoryID` = `products`.`categoryID`
```
Затем затем найдем минимальную цену:

```sql
SELECT `products`.`productName`, `categories`.`categoryName`,`products`.`price` 
FROM `products` INNER JOIN `categories` 
ON `categories`.`categoryID` = `products`.`categoryID` WHERE `price` = ( 
SELECT MIN(`price`) FROM `products`
);
```
Это самый простой пример использования JOIN. Есть ещё несколько вариантов его использования. Для более подробной информации перейти по это ссылке: https://www.w3schools.com/sql/sql_join.asp

#### Псевдонимы

Псевдонимы помогают сделать название столбца красивее или понятнее в случае необходимости. Задаются с помощью ключа `AS`.

```sql
SELECT `products`.`productName` AS `Название`, `categories`.`categoryName` AS `Категория`,`products`.`price` AS `Цена`
FROM `products` INNER JOIN `categories` 
ON `categories`.`categoryID` = `products`.`categoryID` WHERE `price` = ( 
SELECT MIN(`price`) FROM `products`
);
```
#### Update ()

Для того, чтобы внести изменения в таблицу, применяется слово: `UPDATE`.

Использование UPDATE включает в себя:

- выбор таблицы, в которой находится поле, которое мы хотим изменить
- запись нового значения
- использование WHERE, чтобы обозначить конкретное место в таблице

Например изменим цену продукта productID = 1 на 200:

```sql
UPDATE `products` 
SET `price` = 200.0 
WHERE `productID` = 1;
```

#### Удаление записей из таблицы

Удалить записи из таблицы очень просто, используем `DELETE`.
Удалим из продуктов productID = 1:

```sql
DELETE FROM `products` 
WHERE `productID` = 1;
```

#### Удаление таблиц

Если нужно удалить все данные из таблицы, но при этом оставить саму таблицу, следует использовать команду `TRUNCATE`:

```sql
TRUNCATE TABLE `products`; 
```

В случае, если хотим удалить саму таблицу или даже базу данных, то следует использовать команду `DROP`:

Удаление таблицы:

```sql
DROP TABLE `products`;
```
Удаление базы данных:

```sql
DROP DATABASE `store`;
```

---

Официальная документация по MySQL: 
- https://dev.mysql.com/doc/refman/8.0/en/

Дополнительные ресурсы:
- https://www.w3schools.com/sql/
- https://metanit.com/sql/mysql/

